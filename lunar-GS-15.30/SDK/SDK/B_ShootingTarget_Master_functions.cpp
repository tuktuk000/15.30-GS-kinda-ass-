#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: B_ShootingTarget_Master

#include "Basic.hpp"

#include "B_ShootingTarget_Master_classes.hpp"
#include "B_ShootingTarget_Master_parameters.hpp"


namespace SDK
{

// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ExecuteUbergraph_B_ShootingTarget_Master
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::ExecuteUbergraph_B_ShootingTarget_Master(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ExecuteUbergraph_B_ShootingTarget_Master");

	Params::B_ShootingTarget_Master_C_ExecuteUbergraph_B_ShootingTarget_Master Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PostFinishSpawning
// (Event, Public, BlueprintEvent)

void AB_ShootingTarget_Master_C::PostFinishSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PostFinishSpawning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PopUpTargetTimerEvent
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::PopUpTargetTimerEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PopUpTargetTimerEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Target Movement Audio
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Jump_Up_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::Target_Movement_Audio(bool Jump_Up_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Target Movement Audio");

	Params::B_ShootingTarget_Master_C_Target_Movement_Audio Parms{};

	Parms.Jump_Up_ = Jump_Up_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SpawnWeakpointFX
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                ImpactTransform                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::SpawnWeakpointFX(const struct FTransform& ImpactTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SpawnWeakpointFX");

	Params::B_ShootingTarget_Master_C_SpawnWeakpointFX Parms{};

	Parms.ImpactTransform = std::move(ImpactTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Impact Audio
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Check_for_Positive_Score                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AController*                      Instigator_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::Impact_Audio(int32 Check_for_Positive_Score, class AController* Instigator_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Impact Audio");

	Params::B_ShootingTarget_Master_C_Impact_Audio Parms{};

	Parms.Check_for_Positive_Score = Check_for_Positive_Score;
	Parms.Instigator_0 = Instigator_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Knock Down Audio
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Knocked_Down_                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::Knock_Down_Audio(bool Knocked_Down_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Knock Down Audio");

	Params::B_ShootingTarget_Master_C_Knock_Down_Audio Parms{};

	Parms.Knocked_Down_ = Knocked_Down_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetHopTimer
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::SetHopTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetHopTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.HopTimerEvent
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::HopTimerEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "HopTimerEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Hop
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InJumpUpPosition_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::Hop(bool InJumpUpPosition_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Hop");

	Params::B_ShootingTarget_Master_C_Hop Parms{};

	Parms.InJumpUpPosition_0 = InJumpUpPosition_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetHideTargetTimer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TimerDuration                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::SetHideTargetTimer(float TimerDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetHideTargetTimer");

	Params::B_ShootingTarget_Master_C_SetHideTargetTimer Parms{};

	Parms.TimerDuration = TimerDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.HideTargetTimerEvent
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::HideTargetTimerEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "HideTargetTimerEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ResetFromSettings
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::ResetFromSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ResetFromSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.InitializeSettings
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::InitializeSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "InitializeSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PickMeshFromSettings
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::PickMeshFromSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PickMeshFromSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_4_SimpleDynamicMulticastDelegate__DelegateSignature
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_4_SimpleDynamicMulticastDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_4_SimpleDynamicMulticastDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AB_ShootingTarget_Master_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.OnDamageServer
// (BlueprintAuthorityOnly, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     DamageTags                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FVector&                   Momentum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                HitInfo                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AController*                      InstigatedBy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayEffectContextHandle&EffectContext                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void AB_ShootingTarget_Master_C::OnDamageServer(float Damage, const struct FGameplayTagContainer& DamageTags, const struct FVector& Momentum, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser, const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "OnDamageServer");

	Params::B_ShootingTarget_Master_C_OnDamageServer Parms{};

	Parms.Damage = Damage;
	Parms.DamageTags = std::move(DamageTags);
	Parms.Momentum = std::move(Momentum);
	Parms.HitInfo = std::move(HitInfo);
	Parms.InstigatedBy = InstigatedBy;
	Parms.DamageCauser = DamageCauser;
	Parms.EffectContext = std::move(EffectContext);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.KnockdownTarget
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::KnockdownTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "KnockdownTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BndEvt__ProximityTrigger_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void AB_ShootingTarget_Master_C::BndEvt__ProximityTrigger_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BndEvt__ProximityTrigger_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature");

	Params::B_ShootingTarget_Master_C_BndEvt__ProximityTrigger_K2Node_ComponentBoundEvent_3_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_2_AnyPropertyChangedDelegate__DelegateSignature
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_2_AnyPropertyChangedDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_2_AnyPropertyChangedDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PopUpTarget
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    MinigameJustStartedOrStopped                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::PopUpTarget(bool MinigameJustStartedOrStopped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PopUpTarget");

	Params::B_ShootingTarget_Master_C_PopUpTarget Parms{};

	Parms.MinigameJustStartedOrStopped = MinigameJustStartedOrStopped;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_1_AnyPropertyChangedDelegate__DelegateSignature
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_1_AnyPropertyChangedDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BndEvt__ToyOptionsComponent_K2Node_ComponentBoundEvent_1_AnyPropertyChangedDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_0_SimpleDynamicMulticastDelegate__DelegateSignature
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_0_SimpleDynamicMulticastDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BndEvt__FortMinigameProgress_K2Node_ComponentBoundEvent_0_SimpleDynamicMulticastDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.OnLoaded_068F5161459B8B1AEAD4A0B19781287D
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::OnLoaded_068F5161459B8B1AEAD4A0B19781287D(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "OnLoaded_068F5161459B8B1AEAD4A0B19781287D");

	Params::B_ShootingTarget_Master_C_OnLoaded_068F5161459B8B1AEAD4A0B19781287D Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.OnReady_A57ED5A14BEB6A98DB20D88D1582D58A
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::OnReady_A57ED5A14BEB6A98DB20D88D1582D58A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "OnReady_A57ED5A14BEB6A98DB20D88D1582D58A");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Timeline_2__UpdateFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::Timeline_2__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Timeline_2__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.Timeline_2__FinishedFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::Timeline_2__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "Timeline_2__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.KnockDownTimeline__UpdateFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::KnockDownTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "KnockDownTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.KnockDownTimeline__FinishedFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::KnockDownTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "KnockDownTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PopUpTimeline__UpdateFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::PopUpTimeline__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PopUpTimeline__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PopUpTimeline__FinishedFunc
// (BlueprintEvent)

void AB_ShootingTarget_Master_C::PopUpTimeline__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PopUpTimeline__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.CanPopUp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    MinigameJustStartedOrStopped                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   CanPopUp_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::CanPopUp(bool MinigameJustStartedOrStopped, bool* CanPopUp_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "CanPopUp");

	Params::B_ShootingTarget_Master_C_CanPopUp Parms{};

	Parms.MinigameJustStartedOrStopped = MinigameJustStartedOrStopped;

	UObject::ProcessEvent(Func, &Parms);

	if (CanPopUp_0 != nullptr)
		*CanPopUp_0 = Parms.CanPopUp_0;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ResetWeakPoints
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::ResetWeakPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ResetWeakPoints");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.WeakPointWasHit
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit_Result                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UPrimitiveComponent**             HitComponent                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_ShootingTarget_Master_C::WeakPointWasHit(const struct FHitResult& Hit_Result, class UPrimitiveComponent** HitComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "WeakPointWasHit");

	Params::B_ShootingTarget_Master_C_WeakPointWasHit Parms{};

	Parms.Hit_Result = std::move(Hit_Result);

	UObject::ProcessEvent(Func, &Parms);

	if (HitComponent != nullptr)
		*HitComponent = Parms.HitComponent;

	return Parms.ReturnValue;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.PrepareChosenTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              WeakPointComponent_1                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              WeakPointComponent2                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::PrepareChosenTarget(class UStaticMeshComponent* StaticMeshComponent_0, class UPrimitiveComponent* WeakPointComponent_1, class UPrimitiveComponent* WeakPointComponent2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "PrepareChosenTarget");

	Params::B_ShootingTarget_Master_C_PrepareChosenTarget Parms{};

	Parms.StaticMeshComponent_0 = StaticMeshComponent_0;
	Parms.WeakPointComponent_1 = WeakPointComponent_1;
	Parms.WeakPointComponent2 = WeakPointComponent2;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.CalculateScore
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  ScoreToAward                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::CalculateScore(int32* ScoreToAward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "CalculateScore");

	Params::B_ShootingTarget_Master_C_CalculateScore Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ScoreToAward != nullptr)
		*ScoreToAward = Parms.ScoreToAward;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.AwardScore
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerController*            FortPlayerController                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ScoreAwarded                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TeamAwardedPoints                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::AwardScore(class AFortPlayerController* FortPlayerController, int32* ScoreAwarded, int32* TeamAwardedPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "AwardScore");

	Params::B_ShootingTarget_Master_C_AwardScore Parms{};

	Parms.FortPlayerController = FortPlayerController;

	UObject::ProcessEvent(Func, &Parms);

	if (ScoreAwarded != nullptr)
		*ScoreAwarded = Parms.ScoreAwarded;

	if (TeamAwardedPoints != nullptr)
		*TeamAwardedPoints = Parms.TeamAwardedPoints;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ShouldTriggerTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Overlapping_Actor                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              Overlapping_Component                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::ShouldTriggerTarget(class UObject* Overlapping_Actor, class UPrimitiveComponent* Overlapping_Component, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ShouldTriggerTarget");

	Params::B_ShootingTarget_Master_C_ShouldTriggerTarget Parms{};

	Parms.Overlapping_Actor = Overlapping_Actor;
	Parms.Overlapping_Component = Overlapping_Component;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.MinigameIsRunning
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   MinigameIsRunning_0                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::MinigameIsRunning(bool* MinigameIsRunning_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "MinigameIsRunning");

	Params::B_ShootingTarget_Master_C_MinigameIsRunning Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MinigameIsRunning_0 != nullptr)
		*MinigameIsRunning_0 = Parms.MinigameIsRunning_0;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetStartingPosition
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::SetStartingPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetStartingPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.TargetShouldFall
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_ShootingTarget_Master_C::TargetShouldFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "TargetShouldFall");

	Params::B_ShootingTarget_Master_C_TargetShouldFall Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetMaxHealth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewMaxHealth                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::SetMaxHealth(float NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetMaxHealth");

	Params::B_ShootingTarget_Master_C_SetMaxHealth Parms{};

	Parms.NewMaxHealth = NewMaxHealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.HideTarget
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::HideTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "HideTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.InitializeHideTargetTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::InitializeHideTargetTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "InitializeHideTargetTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.ClearBunnyHopTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::ClearBunnyHopTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "ClearBunnyHopTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetBunnyHopTimer
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::SetBunnyHopTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetBunnyHopTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.CheckIfShouldHop
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::CheckIfShouldHop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "CheckIfShouldHop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.CreateWeakPointArray
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::CreateWeakPointArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "CreateWeakPointArray");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.SetAimAssistEnabled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::SetAimAssistEnabled(bool NewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "SetAimAssistEnabled");

	Params::B_ShootingTarget_Master_C_SetAimAssistEnabled Parms{};

	Parms.NewType = NewType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.BlueprintModifyIncomingDamage
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     InTags                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FGameplayEffectContextHandle&EffectContext                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AController*                      EventInstigator                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float AB_ShootingTarget_Master_C::BlueprintModifyIncomingDamage(float Damage, const struct FGameplayTagContainer& InTags, const struct FGameplayEffectContextHandle& EffectContext, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "BlueprintModifyIncomingDamage");

	Params::B_ShootingTarget_Master_C_BlueprintModifyIncomingDamage Parms{};

	Parms.Damage = Damage;
	Parms.InTags = std::move(InTags);
	Parms.EffectContext = std::move(EffectContext);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.UpdateHealthBarVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShouldShowBar                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::UpdateHealthBarVisibility(bool ShouldShowBar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "UpdateHealthBarVisibility");

	Params::B_ShootingTarget_Master_C_UpdateHealthBarVisibility Parms{};

	Parms.ShouldShowBar = ShouldShowBar;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.IsWithinWeakpointBounds
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Impact_location                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class USceneComponent*            Component                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AB_ShootingTarget_Master_C::IsWithinWeakpointBounds(const struct FVector& Impact_location, const class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "IsWithinWeakpointBounds");

	Params::B_ShootingTarget_Master_C_IsWithinWeakpointBounds Parms{};

	Parms.Impact_location = std::move(Impact_location);
	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.CalculateDamageFromWeaponData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFortWeaponItemDefinition*        WeaponData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InDamage                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  OutDamage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::CalculateDamageFromWeaponData(class UFortWeaponItemDefinition* WeaponData, float InDamage, float* OutDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "CalculateDamageFromWeaponData");

	Params::B_ShootingTarget_Master_C_CalculateDamageFromWeaponData Parms{};

	Parms.WeaponData = WeaponData;
	Parms.InDamage = InDamage;

	UObject::ProcessEvent(Func, &Parms);

	if (OutDamage != nullptr)
		*OutDamage = Parms.OutDamage;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.GetWeaponDataFromDamageCauser
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UFortWeaponItemDefinition**       OutWeaponData                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AB_ShootingTarget_Master_C::GetWeaponDataFromDamageCauser(class UObject* DamageCauser, class UFortWeaponItemDefinition** OutWeaponData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "GetWeaponDataFromDamageCauser");

	Params::B_ShootingTarget_Master_C_GetWeaponDataFromDamageCauser Parms{};

	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	if (OutWeaponData != nullptr)
		*OutWeaponData = Parms.OutWeaponData;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.WeakPointArrayContainsItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   ArrayContainsItems                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AB_ShootingTarget_Master_C::WeakPointArrayContainsItems(bool* ArrayContainsItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "WeakPointArrayContainsItems");

	Params::B_ShootingTarget_Master_C_WeakPointArrayContainsItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ArrayContainsItems != nullptr)
		*ArrayContainsItems = Parms.ArrayContainsItems;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.RestoreToMaxHealth
// (Public, BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::RestoreToMaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "RestoreToMaxHealth");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.OnRep_TargetMeshSetting
// (BlueprintCallable, BlueprintEvent)

void AB_ShootingTarget_Master_C::OnRep_TargetMeshSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "OnRep_TargetMeshSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.GetCollisionStaticMesh
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UStaticMesh* AB_ShootingTarget_Master_C::GetCollisionStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "GetCollisionStaticMesh");

	Params::B_ShootingTarget_Master_C_GetCollisionStaticMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function B_ShootingTarget_Master.B_ShootingTarget_Master_C.GetMeshComponents
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UMeshComponent*>           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash)

TArray<class UMeshComponent*> AB_ShootingTarget_Master_C::GetMeshComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_ShootingTarget_Master_C", "GetMeshComponents");

	Params::B_ShootingTarget_Master_C_GetMeshComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

