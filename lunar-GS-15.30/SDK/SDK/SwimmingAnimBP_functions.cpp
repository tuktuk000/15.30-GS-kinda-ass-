#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: SwimmingAnimBP

#include "Basic.hpp"

#include "SwimmingAnimBP_classes.hpp"
#include "SwimmingAnimBP_parameters.hpp"


namespace SDK
{

// Function SwimmingAnimBP.SwimmingAnimBP_C.ExecuteUbergraph_SwimmingAnimBP
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void USwimmingAnimBP_C::ExecuteUbergraph_SwimmingAnimBP(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "ExecuteUbergraph_SwimmingAnimBP");

	Params::SwimmingAnimBP_C_ExecuteUbergraph_SwimmingAnimBP Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimMovementAccelAdditive_Exited_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimMovementAccelAdditive_Exited_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimMovementAccelAdditive_Exited_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimStartAdditive_Entered_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimStartAdditive_Entered_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimStartAdditive_Entered_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimSprintSlow_Entered_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimSprintSlow_Entered_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimSprintSlow_Entered_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimSprint_Entered_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimSprint_Entered_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimSprint_Entered_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimSprintStart_Exited_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimSprintStart_Exited_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimSprintStart_Exited_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimNotify_SwimSprintStart_Entered_Layer
// (BlueprintCallable, BlueprintEvent)

void USwimmingAnimBP_C::AnimNotify_SwimSprintStart_Entered_Layer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimNotify_SwimSprintStart_Entered_Layer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_E6B49F01423E469AF176989D25F6BA2A
// (BlueprintEvent)

void USwimmingAnimBP_C::EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_E6B49F01423E469AF176989D25F6BA2A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_E6B49F01423E469AF176989D25F6BA2A");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_5830B69443C9B79B5F980CAE5DEC8E36
// (BlueprintEvent)

void USwimmingAnimBP_C::EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_5830B69443C9B79B5F980CAE5DEC8E36()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "EvaluateGraphExposedInputs_ExecuteUbergraph_SwimmingAnimBP_AnimGraphNode_TransitionResult_5830B69443C9B79B5F980CAE5DEC8E36");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.AnimGraph
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPoseLink*                       AnimGraph_0                                            (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::AnimGraph(struct FPoseLink* AnimGraph_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "AnimGraph");

	Params::SwimmingAnimBP_C_AnimGraph Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AnimGraph_0 != nullptr)
		*AnimGraph_0 = std::move(Parms.AnimGraph_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 MainPlayerAnimBP                                       (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingLayer_0                                        (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingLayer(const struct FPoseLink& MainPlayerAnimBP, struct FPoseLink* SwimmingLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingLayer");

	Params::SwimmingAnimBP_C_SwimmingLayer Parms{};

	Parms.MainPlayerAnimBP = std::move(MainPlayerAnimBP);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingLayer_0 != nullptr)
		*SwimmingLayer_0 = std::move(Parms.SwimmingLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingSprintLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughSwimmingSprint                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    IsHidingInPropLayer_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FPoseLink*                       SwimmingSprintLayer_0                                  (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingSprintLayer(const struct FPoseLink& PassThroughSwimmingSprint, bool IsHidingInPropLayer_0, struct FPoseLink* SwimmingSprintLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingSprintLayer");

	Params::SwimmingAnimBP_C_SwimmingSprintLayer Parms{};

	Parms.PassThroughSwimmingSprint = std::move(PassThroughSwimmingSprint);
	Parms.IsHidingInPropLayer_0 = IsHidingInPropLayer_0;

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingSprintLayer_0 != nullptr)
		*SwimmingSprintLayer_0 = std::move(Parms.SwimmingSprintLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingMovementAdditiveLayerPose
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughSwimmingMovementAdditive                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingMovementAdditiveLayerPose_0                    (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingMovementAdditiveLayerPose(const struct FPoseLink& PassThroughSwimmingMovementAdditive, struct FPoseLink* SwimmingMovementAdditiveLayerPose_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingMovementAdditiveLayerPose");

	Params::SwimmingAnimBP_C_SwimmingMovementAdditiveLayerPose Parms{};

	Parms.PassThroughSwimmingMovementAdditive = std::move(PassThroughSwimmingMovementAdditive);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingMovementAdditiveLayerPose_0 != nullptr)
		*SwimmingMovementAdditiveLayerPose_0 = std::move(Parms.SwimmingMovementAdditiveLayerPose_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingUpperBodyPoseTargetingLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughSwimmingUpperBodyPoseTargeting              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingUpperBodyPoseTargetingLayer_0                  (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingUpperBodyPoseTargetingLayer(const struct FPoseLink& PassThroughSwimmingUpperBodyPoseTargeting, struct FPoseLink* SwimmingUpperBodyPoseTargetingLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingUpperBodyPoseTargetingLayer");

	Params::SwimmingAnimBP_C_SwimmingUpperBodyPoseTargetingLayer Parms{};

	Parms.PassThroughSwimmingUpperBodyPoseTargeting = std::move(PassThroughSwimmingUpperBodyPoseTargeting);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingUpperBodyPoseTargetingLayer_0 != nullptr)
		*SwimmingUpperBodyPoseTargetingLayer_0 = std::move(Parms.SwimmingUpperBodyPoseTargetingLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingUpperBodyPoseNonTargetingLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughSwimmingUpperBodyPoseNonTargeting           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingUpperBodyPoseNonTargetingLayer_0               (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingUpperBodyPoseNonTargetingLayer(const struct FPoseLink& PassThroughSwimmingUpperBodyPoseNonTargeting, struct FPoseLink* SwimmingUpperBodyPoseNonTargetingLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingUpperBodyPoseNonTargetingLayer");

	Params::SwimmingAnimBP_C_SwimmingUpperBodyPoseNonTargetingLayer Parms{};

	Parms.PassThroughSwimmingUpperBodyPoseNonTargeting = std::move(PassThroughSwimmingUpperBodyPoseNonTargeting);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingUpperBodyPoseNonTargetingLayer_0 != nullptr)
		*SwimmingUpperBodyPoseNonTargetingLayer_0 = std::move(Parms.SwimmingUpperBodyPoseNonTargetingLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingLowerBodyLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 UpperBody_Cache                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FPoseLink&                 PreUpperBodySlot_Cache                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FPoseLink&                 PassThroughSwimmingLowerBody                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingLowerBodyLayer_0                               (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingLowerBodyLayer(const struct FPoseLink& UpperBody_Cache, const struct FPoseLink& PreUpperBodySlot_Cache, const struct FPoseLink& PassThroughSwimmingLowerBody, struct FPoseLink* SwimmingLowerBodyLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingLowerBodyLayer");

	Params::SwimmingAnimBP_C_SwimmingLowerBodyLayer Parms{};

	Parms.UpperBody_Cache = std::move(UpperBody_Cache);
	Parms.PreUpperBodySlot_Cache = std::move(PreUpperBodySlot_Cache);
	Parms.PassThroughSwimmingLowerBody = std::move(PassThroughSwimmingLowerBody);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingLowerBodyLayer_0 != nullptr)
		*SwimmingLowerBodyLayer_0 = std::move(Parms.SwimmingLowerBodyLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingAdditiveLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 IdleAdditive_Cache                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FPoseLink&                 MovementAdditiveLayerPose_Cache                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FPoseLink&                 FullBody                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// float                                   PlayMeleeAttackAOLayer_0                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DisableArmsHeadAdditiveCurveAlphaLayer_0               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DisableIKRootAdditiveCurveAlphaLayer_0                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LocomotionAdditiveAlphaLayer_0                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MainInstanceAdditiveLayerAlpha_0                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FPoseLink&                 UpperAndLowerBody_Cache                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FPoseLink&                 SprintingPose_PostMask_Cache                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingAdditiveLayer_0                                (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingAdditiveLayer(const struct FPoseLink& IdleAdditive_Cache, const struct FPoseLink& MovementAdditiveLayerPose_Cache, const struct FPoseLink& FullBody, float PlayMeleeAttackAOLayer_0, float DisableArmsHeadAdditiveCurveAlphaLayer_0, float DisableIKRootAdditiveCurveAlphaLayer_0, float LocomotionAdditiveAlphaLayer_0, float MainInstanceAdditiveLayerAlpha_0, const struct FPoseLink& UpperAndLowerBody_Cache, const struct FPoseLink& SprintingPose_PostMask_Cache, struct FPoseLink* SwimmingAdditiveLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingAdditiveLayer");

	Params::SwimmingAnimBP_C_SwimmingAdditiveLayer Parms{};

	Parms.IdleAdditive_Cache = std::move(IdleAdditive_Cache);
	Parms.MovementAdditiveLayerPose_Cache = std::move(MovementAdditiveLayerPose_Cache);
	Parms.FullBody = std::move(FullBody);
	Parms.PlayMeleeAttackAOLayer_0 = PlayMeleeAttackAOLayer_0;
	Parms.DisableArmsHeadAdditiveCurveAlphaLayer_0 = DisableArmsHeadAdditiveCurveAlphaLayer_0;
	Parms.DisableIKRootAdditiveCurveAlphaLayer_0 = DisableIKRootAdditiveCurveAlphaLayer_0;
	Parms.LocomotionAdditiveAlphaLayer_0 = LocomotionAdditiveAlphaLayer_0;
	Parms.MainInstanceAdditiveLayerAlpha_0 = MainInstanceAdditiveLayerAlpha_0;
	Parms.UpperAndLowerBody_Cache = std::move(UpperAndLowerBody_Cache);
	Parms.SprintingPose_PostMask_Cache = std::move(SprintingPose_PostMask_Cache);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingAdditiveLayer_0 != nullptr)
		*SwimmingAdditiveLayer_0 = std::move(Parms.SwimmingAdditiveLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingFullBodyAdditiveLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughFullBodyAdditive                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FPoseLink*                       SwimmingFullBodyAdditiveLayer_0                        (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingFullBodyAdditiveLayer(const struct FPoseLink& PassThroughFullBodyAdditive, struct FPoseLink* SwimmingFullBodyAdditiveLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingFullBodyAdditiveLayer");

	Params::SwimmingAnimBP_C_SwimmingFullBodyAdditiveLayer Parms{};

	Parms.PassThroughFullBodyAdditive = std::move(PassThroughFullBodyAdditive);

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingFullBodyAdditiveLayer_0 != nullptr)
		*SwimmingFullBodyAdditiveLayer_0 = std::move(Parms.SwimmingFullBodyAdditiveLayer_0);
}


// Function SwimmingAnimBP.SwimmingAnimBP_C.SwimmingDiveJumpingLayer
// (HasOutParams, BlueprintCallable)
// Parameters:
// const struct FPoseLink&                 PassThroughSwimmingDiveJumping                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    IsHidingInPropLayer2_0                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   MainInstanceDiveJumpLayerAlpha_0                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EFortPlayerAnimBodyType                 AnimBodyTypePassThrough_0                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FPoseLink*                       SwimmingDiveJumpingLayer_0                             (Parm, OutParm, NoDestructor)

void USwimmingAnimBP_C::SwimmingDiveJumpingLayer(const struct FPoseLink& PassThroughSwimmingDiveJumping, bool IsHidingInPropLayer2_0, float MainInstanceDiveJumpLayerAlpha_0, EFortPlayerAnimBodyType AnimBodyTypePassThrough_0, struct FPoseLink* SwimmingDiveJumpingLayer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingAnimBP_C", "SwimmingDiveJumpingLayer");

	Params::SwimmingAnimBP_C_SwimmingDiveJumpingLayer Parms{};

	Parms.PassThroughSwimmingDiveJumping = std::move(PassThroughSwimmingDiveJumping);
	Parms.IsHidingInPropLayer2_0 = IsHidingInPropLayer2_0;
	Parms.MainInstanceDiveJumpLayerAlpha_0 = MainInstanceDiveJumpLayerAlpha_0;
	Parms.AnimBodyTypePassThrough_0 = AnimBodyTypePassThrough_0;

	UObject::ProcessEvent(Func, &Parms);

	if (SwimmingDiveJumpingLayer_0 != nullptr)
		*SwimmingDiveJumpingLayer_0 = std::move(Parms.SwimmingDiveJumpingLayer_0);
}

}

