#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: MinigameSettingsMachine

#include "Basic.hpp"

#include "MinigameSettingsMachine_classes.hpp"
#include "MinigameSettingsMachine_parameters.hpp"


namespace SDK
{

// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ExecuteUbergraph_MinigameSettingsMachine
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::ExecuteUbergraph_MinigameSettingsMachine(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ExecuteUbergraph_MinigameSettingsMachine");

	Params::MinigameSettingsMachine_C_ExecuteUbergraph_MinigameSettingsMachine Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.OnMinigameStateChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortMinigame*                    Minigame                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EFortMinigameState                      MinigameState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::OnMinigameStateChanged(class AFortMinigame* Minigame, EFortMinigameState MinigameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "OnMinigameStateChanged");

	Params::MinigameSettingsMachine_C_OnMinigameStateChanged Parms{};

	Parms.Minigame = Minigame;
	Parms.MinigameState = MinigameState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.AbandonMinigameHelper
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::AbandonMinigameHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "AbandonMinigameHelper");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.StartMinigameHelper
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::StartMinigameHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "StartMinigameHelper");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.OnGameSettingsUpdated
// (BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::OnGameSettingsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "OnGameSettingsUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AMinigameSettingsMachine_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetPickupSpawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector*                         SpawnLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetPickupSpawnLocation(struct FVector* SpawnLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetPickupSpawnLocation");

	Params::MinigameSettingsMachine_C_GetPickupSpawnLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpawnLocation != nullptr)
		*SpawnLocation = std::move(Parms.SpawnLocation);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.HasMinigameStarted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bHasStarted                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::HasMinigameStarted(bool* bHasStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "HasMinigameStarted");

	Params::MinigameSettingsMachine_C_HasMinigameStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bHasStarted != nullptr)
		*bHasStarted = Parms.bHasStarted;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateGameMode
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateGameMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTimeLimit
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTimeLimit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTimeLimit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetCurrentMinigame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AFortMinigame**                   Minigame                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetCurrentMinigame(class AFortMinigame** Minigame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetCurrentMinigame");

	Params::MinigameSettingsMachine_C_GetCurrentMinigame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Minigame != nullptr)
		*Minigame = Parms.Minigame;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateSpawnLocationSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateSpawnLocationSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateSpawnLocationSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTeamSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTeamSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTeamSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdatePostGameSpawnLocationSetting
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdatePostGameSpawnLocationSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdatePostGameSpawnLocationSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdatePlayerLives
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdatePlayerLives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdatePlayerLives");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateAutoEndTeamThreshold
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateAutoEndTeamThreshold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateAutoEndTeamThreshold");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTeamToMoveToWhenOutOfSpawns
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTeamToMoveToWhenOutOfSpawns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTeamToMoveToWhenOutOfSpawns");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateEndConditions
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateEndConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateEndConditions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateAutoStart
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateAutoStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateAutoStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.TryAddEndCondition_CollectItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFortMinigameStatQuery>&  EndConditions                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::TryAddEndCondition_CollectItems(TArray<struct FFortMinigameStatQuery>& EndConditions, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "TryAddEndCondition_CollectItems");

	Params::MinigameSettingsMachine_C_TryAddEndCondition_CollectItems Parms{};

	Parms.EndConditions = std::move(EndConditions);

	UObject::ProcessEvent(Func, &Parms);

	EndConditions = std::move(Parms.EndConditions);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateJoinInProgress
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateJoinInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateJoinInProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateMinigameMutators
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateMinigameMutators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateMinigameMutators");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateTotalRounds
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateTotalRounds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateTotalRounds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.TryAddEndCondition_DestroyObjects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FFortMinigameStatQuery>&  EndConditions                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::TryAddEndCondition_DestroyObjects(TArray<struct FFortMinigameStatQuery>& EndConditions, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "TryAddEndCondition_DestroyObjects");

	Params::MinigameSettingsMachine_C_TryAddEndCondition_DestroyObjects Parms{};

	Parms.EndConditions = std::move(EndConditions);

	UObject::ProcessEvent(Func, &Parms);

	EndConditions = std::move(Parms.EndConditions);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.FillTrackedStats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::FillTrackedStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "FillTrackedStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetScoreboardStatsArray
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UClass*>*                  ScoreboardStats                                        (Parm, OutParm, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetScoreboardStatsArray(TArray<class UClass*>* ScoreboardStats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetScoreboardStatsArray");

	Params::MinigameSettingsMachine_C_GetScoreboardStatsArray Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ScoreboardStats != nullptr)
		*ScoreboardStats = std::move(Parms.ScoreboardStats);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.Game Mode Preset Upgrade Path
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::Game_Mode_Preset_Upgrade_Path()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "Game Mode Preset Upgrade Path");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetUIExtensions
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer*           Return_Value                                           (Parm, OutParm)

void AMinigameSettingsMachine_C::GetUIExtensions(struct FGameplayTagContainer* Return_Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetUIExtensions");

	Params::MinigameSettingsMachine_C_GetUIExtensions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = std::move(Parms.Return_Value);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateClassSettings
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateClassSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateClassSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdatePlayerPersistence
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdatePlayerPersistence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdatePlayerPersistence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateGameSettings
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateGameSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.AdditionalUIExtensionValidityChecks
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTagContainer&     TagContainer                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// bool*                                   bUIExtensionIsValid                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AMinigameSettingsMachine_C::AdditionalUIExtensionValidityChecks(const struct FGameplayTagContainer& TagContainer, bool* bUIExtensionIsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "AdditionalUIExtensionValidityChecks");

	Params::MinigameSettingsMachine_C_AdditionalUIExtensionValidityChecks Parms{};

	Parms.TagContainer = std::move(TagContainer);

	UObject::ProcessEvent(Func, &Parms);

	if (bUIExtensionIsValid != nullptr)
		*bUIExtensionIsValid = Parms.bUIExtensionIsValid;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.UpdateGameStartCountdown
// (Public, BlueprintCallable, BlueprintEvent)

void AMinigameSettingsMachine_C::UpdateGameStartCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "UpdateGameStartCountdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.Override Custom End Callouts
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    DeviceVictoryCallout_0                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    DeviceDefeatCallout_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::Override_Custom_End_Callouts(const class FString& DeviceVictoryCallout_0, const class FString& DeviceDefeatCallout_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "Override Custom End Callouts");

	Params::MinigameSettingsMachine_C_Override_Custom_End_Callouts Parms{};

	Parms.DeviceVictoryCallout_0 = std::move(DeviceVictoryCallout_0);
	Parms.DeviceDefeatCallout_0 = std::move(DeviceDefeatCallout_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetEndCallouts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString*                          CustomVictoryCallout_0                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          CustomDefeatCallout_0                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AMinigameSettingsMachine_C::GetEndCallouts(class FString* CustomVictoryCallout_0, class FString* CustomDefeatCallout_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetEndCallouts");

	Params::MinigameSettingsMachine_C_GetEndCallouts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CustomVictoryCallout_0 != nullptr)
		*CustomVictoryCallout_0 = std::move(Parms.CustomVictoryCallout_0);

	if (CustomDefeatCallout_0 != nullptr)
		*CustomDefeatCallout_0 = std::move(Parms.CustomDefeatCallout_0);
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintCanInteract
// (HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const EInteractionBeingAttempted        InteractionBeingAttempted                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const ETInteractionType                 InteractionType                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AMinigameSettingsMachine_C::BlueprintCanInteract(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted, const ETInteractionType InteractionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintCanInteract");

	Params::MinigameSettingsMachine_C_BlueprintCanInteract Parms{};

	Parms.InteractingPawn = InteractingPawn;
	Parms.InteractionBeingAttempted = InteractionBeingAttempted;
	Parms.InteractionType = InteractionType;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintGetInteractionString
// (HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const EInteractionBeingAttempted        InteractionBeingAttempted                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AMinigameSettingsMachine_C::BlueprintGetInteractionString(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintGetInteractionString");

	Params::MinigameSettingsMachine_C_BlueprintGetInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;
	Parms.InteractionBeingAttempted = InteractionBeingAttempted;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.BlueprintGetFailedInteractionString
// (HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const class AFortPawn*                  InteractingPawn                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const EInteractionBeingAttempted        InteractionBeingAttempted                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AMinigameSettingsMachine_C::BlueprintGetFailedInteractionString(const class AFortPawn* InteractingPawn, const EInteractionBeingAttempted InteractionBeingAttempted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "BlueprintGetFailedInteractionString");

	Params::MinigameSettingsMachine_C_BlueprintGetFailedInteractionString Parms{};

	Parms.InteractingPawn = InteractingPawn;
	Parms.InteractionBeingAttempted = InteractionBeingAttempted;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function MinigameSettingsMachine.MinigameSettingsMachine_C.GetTeamSetting
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 AMinigameSettingsMachine_C::GetTeamSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MinigameSettingsMachine_C", "GetTeamSetting");

	Params::MinigameSettingsMachine_C_GetTeamSetting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

