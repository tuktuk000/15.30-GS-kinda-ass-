#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: HydrogenRuntime

#include "Basic.hpp"

#include "HydrogenRuntime_classes.hpp"
#include "HydrogenRuntime_parameters.hpp"


namespace SDK
{

// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.ActivateTheStormShield
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::ActivateTheStormShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "ActivateTheStormShield");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.AddBonusVictoryPointsForLockedCapturePoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   InTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::AddBonusVictoryPointsForLockedCapturePoints(uint8 InTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "AddBonusVictoryPointsForLockedCapturePoints");

	Params::FortAthenaMutator_Hydrogen_AddBonusVictoryPointsForLockedCapturePoints Parms{};

	Parms.InTeam = InTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.CheckVictoryPoints
// (Final, Native, Protected)
// Parameters:
// float                                   TimePassed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::CheckVictoryPoints(float TimePassed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "CheckVictoryPoints");

	Params::FortAthenaMutator_Hydrogen_CheckVictoryPoints Parms{};

	Parms.TimePassed = TimePassed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.EndGame
// (Final, Native, Protected)
// Parameters:
// uint8                                   Winner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::EndGame(uint8 Winner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "EndGame");

	Params::FortAthenaMutator_Hydrogen_EndGame Parms{};

	Parms.Winner = Winner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetActorOnPathLocation
// (Final, Native, Protected, HasDefaults)
// Parameters:
// int32                                   InPathIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AFortAthenaMutator_Hydrogen::GetActorOnPathLocation(int32 InPathIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetActorOnPathLocation");

	Params::FortAthenaMutator_Hydrogen_GetActorOnPathLocation Parms{};

	Parms.InPathIndex = InPathIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetNextActorOnPathLocation
// (Final, Native, Protected, HasDefaults)
// Parameters:
// int32                                   InPathIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AFortAthenaMutator_Hydrogen::GetNextActorOnPathLocation(int32 InPathIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetNextActorOnPathLocation");

	Params::FortAthenaMutator_Hydrogen_GetNextActorOnPathLocation Parms{};

	Parms.InPathIndex = InPathIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetOwnedCapturePointCount
// (Final, Native, Protected)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AFortAthenaMutator_Hydrogen::GetOwnedCapturePointCount(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetOwnedCapturePointCount");

	Params::FortAthenaMutator_Hydrogen_GetOwnedCapturePointCount Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetTimeToNextNode
// (Final, Native, Protected)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFortAthenaMutator_Hydrogen::GetTimeToNextNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetTimeToNextNode");

	Params::FortAthenaMutator_Hydrogen_GetTimeToNextNode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GiveEOMBonusAccolade
// (Final, Native, Public)

void AFortAthenaMutator_Hydrogen::GiveEOMBonusAccolade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GiveEOMBonusAccolade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GiveObjectiveAccolade
// (Final, Native, Public)
// Parameters:
// class AFortPlayerControllerAthena*      FortController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::GiveObjectiveAccolade(class AFortPlayerControllerAthena* FortController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GiveObjectiveAccolade");

	Params::FortAthenaMutator_Hydrogen_GiveObjectiveAccolade Parms{};

	Parms.FortController = FortController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GotoNextStormShieldNode
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::GotoNextStormShieldNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GotoNextStormShieldNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.OnRep_HydrogenTeamPointsChanged
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::OnRep_HydrogenTeamPointsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "OnRep_HydrogenTeamPointsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.OnRep_WinningTeam
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::OnRep_WinningTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "OnRep_WinningTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.OwningTeamChange
// (Final, Native, Public)
// Parameters:
// class AHydrogenObjectiveActor*          Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::OwningTeamChange(class AHydrogenObjectiveActor* Objective, uint8 NewTeam, uint8 OldTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "OwningTeamChange");

	Params::FortAthenaMutator_Hydrogen_OwningTeamChange Parms{};

	Parms.Objective = Objective;
	Parms.NewTeam = NewTeam;
	Parms.OldTeam = OldTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.PositionHydrogenStormShield
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::PositionHydrogenStormShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "PositionHydrogenStormShield");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.SetupSafeZoneRoute
// (Final, Native, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   StartVector                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndVector                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::SetupSafeZoneRoute(const struct FVector& StartVector, const struct FVector& EndVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "SetupSafeZoneRoute");

	Params::FortAthenaMutator_Hydrogen_SetupSafeZoneRoute Parms{};

	Parms.StartVector = std::move(StartVector);
	Parms.EndVector = std::move(EndVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.TickHydrogenStormShield
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFortAthenaMutator_Hydrogen::TickHydrogenStormShield(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "TickHydrogenStormShield");

	Params::FortAthenaMutator_Hydrogen_TickHydrogenStormShield Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.UpdateCapturePointsCounted
// (Final, Native, Protected)

void AFortAthenaMutator_Hydrogen::UpdateCapturePointsCounted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "UpdateCapturePointsCounted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.bHasStormStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFortAthenaMutator_Hydrogen::bHasStormStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "bHasStormStarted");

	Params::FortAthenaMutator_Hydrogen_bHasStormStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.bHasWinnerBeenDeclared
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFortAthenaMutator_Hydrogen::bHasWinnerBeenDeclared() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "bHasWinnerBeenDeclared");

	Params::FortAthenaMutator_Hydrogen_bHasWinnerBeenDeclared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetAllCapturePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AHydrogenObjectiveActor*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TArray<class AHydrogenObjectiveActor*> AFortAthenaMutator_Hydrogen::GetAllCapturePoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetAllCapturePoints");

	Params::FortAthenaMutator_Hydrogen_GetAllCapturePoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetSortedActivePointIndices
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>*                          OutSortedIndices                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::GetSortedActivePointIndices(TArray<int32>* OutSortedIndices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetSortedActivePointIndices");

	Params::FortAthenaMutator_Hydrogen_GetSortedActivePointIndices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSortedIndices != nullptr)
		*OutSortedIndices = std::move(Parms.OutSortedIndices);
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.GetStormSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFortAthenaMutator_Hydrogen::GetStormSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "GetStormSpeed");

	Params::FortAthenaMutator_Hydrogen_GetStormSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.IsInStormShield
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   TestLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFortAthenaMutator_Hydrogen::IsInStormShield(const struct FVector& TestLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "IsInStormShield");

	Params::FortAthenaMutator_Hydrogen_IsInStormShield Parms{};

	Parms.TestLocation = std::move(TestLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function HydrogenRuntime.FortAthenaMutator_Hydrogen.SetCapturePointFillAmount
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AHydrogenObjectiveActor*          InCapturePointActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InPlayerTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortAthenaMutator_Hydrogen::SetCapturePointFillAmount(class AHydrogenObjectiveActor* InCapturePointActor, uint8 InPlayerTeam) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAthenaMutator_Hydrogen", "SetCapturePointFillAmount");

	Params::FortAthenaMutator_Hydrogen_SetCapturePointFillAmount Parms{};

	Parms.InCapturePointActor = InCapturePointActor;
	Parms.InPlayerTeam = InPlayerTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.CheckForStorm
// (Final, Native, Protected)

void AHydrogenObjectiveActor::CheckForStorm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "CheckForStorm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.FlashIcon
// (Final, Native, Protected, BlueprintCallable)

void AHydrogenObjectiveActor::FlashIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "FlashIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnComponentBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::OnComponentBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnComponentBeginOverlap");

	Params::HydrogenObjectiveActor_OnComponentBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnMutatorAvailable
// (Final, Native, Protected, BlueprintCallable)

void AHydrogenObjectiveActor::OnMutatorAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnMutatorAvailable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnOverlapBegin");

	Params::HydrogenObjectiveActor_OnOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnRep_bIsActive
// (Final, Native, Protected)

void AHydrogenObjectiveActor::OnRep_bIsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnRep_bIsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnRep_HydrogenCaptureStateEnum
// (Final, Native, Private)

void AHydrogenObjectiveActor::OnRep_HydrogenCaptureStateEnum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnRep_HydrogenCaptureStateEnum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnRep_OwningTeam
// (Final, Native, Private)

void AHydrogenObjectiveActor::OnRep_OwningTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnRep_OwningTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnRep_TeamsOnCapturePoint
// (Final, Native, Private)

void AHydrogenObjectiveActor::OnRep_TeamsOnCapturePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnRep_TeamsOnCapturePoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.OnTimelineFlashing
// (Final, Native, Protected)
// Parameters:
// float                                   IconOpacity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::OnTimelineFlashing(float IconOpacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "OnTimelineFlashing");

	Params::HydrogenObjectiveActor_OnTimelineFlashing Parms{};

	Parms.IconOpacity = IconOpacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.PlayContestedMapTimeline
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHydrogenObjectiveActor::PlayContestedMapTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "PlayContestedMapTimeline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function HydrogenRuntime.HydrogenObjectiveActor.ProcessOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::ProcessOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "ProcessOverlap");

	Params::HydrogenObjectiveActor_ProcessOverlap Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::SetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "SetActive");

	Params::HydrogenObjectiveActor_SetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.SetUpMaterialInstanceDynamic
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSlateBrush*                     MapIconBrush                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic**        DrawBrushMID                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHydrogenObjectiveActor::SetUpMaterialInstanceDynamic(struct FSlateBrush* MapIconBrush, class UMaterialInstanceDynamic** DrawBrushMID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "SetUpMaterialInstanceDynamic");

	Params::HydrogenObjectiveActor_SetUpMaterialInstanceDynamic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MapIconBrush != nullptr)
		*MapIconBrush = std::move(Parms.MapIconBrush);

	if (DrawBrushMID != nullptr)
		*DrawBrushMID = Parms.DrawBrushMID;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.WaitForMutator
// (Final, Native, Protected)

void AHydrogenObjectiveActor::WaitForMutator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "WaitForMutator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function HydrogenRuntime.HydrogenObjectiveActor.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHydrogenObjectiveActor::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HydrogenObjectiveActor", "GetIsActive");

	Params::HydrogenObjectiveActor_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

